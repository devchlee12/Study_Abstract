이 페이지가 다루는 내용
- final이 아닌 Object메소드들을 언제 어떻게 재정의 해야하는지
	- final 아닌 Object메소드들은 규약이 명확히 정해져있고, 함부로 재정의하면 이 규약을 준수한다고 가정하는 클래스들을 오동작 하게 만들 수 있으므로 중요.
- Comparable.compareTo 재정의 방법

### 아이템 10. equals는 일반 규약을 지켜 재정의하라

equals메소드는 재정의하기 쉬워보이지만 사실 함정이 좀 있음.

그래서 되도록이면 재정의를 안하는 방향으로 가는것이 좋긴하다.

그렇다면 어떤 상황에서 재정의가 필요 없을까?
- 각 인스턴스가 본질적으로 고유할 때
	- 예를 들어, Thread는 값을 표현하는 것이 아니라, 개체를 표현하므로 equals 재정의가 필요 없다.
- 인스턴스의 논리적 동치성을 검사할 일이 없을 때
	- Pattern 클래스 같은 경우에는 equals를 재정의해서 같은 정규표현식인지 검사함. 그런데 이런 과정이 필요 없는 클래스도 있으므로 그럴 때는 재정의 필요 없다.
- 상위 클래스에서 재정의한 equals가 하위클래스에도 딱 들어맞을 때
	- 예를 들어, Set은 AbstractSet이 구현한 equals메소드가 딱 맞아서 그냥 쓴다
- 클래스가 private이거나 package-private이고 equals메소드를 호출할 일이 없을 때

반대로 재정의가 필요한 상황은?
- 논리적 동치성이필요한데, 상위 클래스의 equals가 논리적 동치성 비교하도록 재정의 되어있지 않을 때
	- equals가 논리적 동치성을 확인하도록 재정의해두면 Map과 Set의 키로 사용 가능

equals 메소드의 일반 규약
- 반사성 : null 아닌 모든 참조값 x에 대해, x.equals(x) 는 true
- 대칭성 : null 아닌 모든 참조값 x에 대해, x.equals(y) 이면, y.equals(x)
- 추이성 : null 아닌 모든 참조값 x에 대해, x.equals(y)이고, y.equals(z) 이면 x.equals(z) 
- 일관성 : null 아닌 모든 참조값 x에 대해, x.equals(y)를 반복해서 호출하면 계속 같은 값을 반환
- null-아님 : null 아닌 모든 참조값 x에 대해 x.equals(null)은 false


