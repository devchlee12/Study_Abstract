이 페이지가 담고 있는 내용
- 자바가 변화하는 이유
- 자바 8과 자바 9의 새로운 핵심 기능 소개
### 자바가 변화하는 이유

자바는 왜 변화할까?
- 자연어에 더 가까운 방식으로 코드를 구현하기 위해
- 멀티코어 CPU 대중화와 같은 하드웨어적인 변화에 대응하려고
	- 원래는 스레드를 사용해야했는데, 이러면 관리하기가 힘들었고, 많은 문제가 발생했음

그렇다면 자바8은 어떤 기능을 새로 제공하는가?
 - 스트림 API
	 - 한번에 한개 씩 만들어지는 연속적인 데이터 항목들의 모임
	- 기존에는 한번에 한 항목씩 처리해야했다면, 자바8부터는 스트림으로 처리할 수 있다
	- 스트림으로 처리하면 스레드 없이 병렬성을 얻을 수 있다
 - 메소드에 코드를 전달하는 기법 (동작 파라미터화)
	 - 자바 8이전에는 메소드를 다른 메소드로 전달할 방법이 없었음. 그래서 Comparator 객체를 만들어서 넘겨주는 등 복잡하게 처리함
	 - 자바8에서는 메소드를 다른 메소드의 인수로 넘겨줄 수 있다
	 - 다만, 스트림 메소드로 전달되는 코드는 공유된 가변데이터에 접근하면 안됨
		 - 이걸 순수함수라고 한다
		 - 그냥 synchronized로 공유데이터 보호하면 되지 않나?
			 - synchronized를 사용하면 코드가 순차적으로 실행되어야하므로, 멀티코어에서 병렬이라는 목적이 무력화된다. 따라서 생각보다 더 대가가 크다.
 - 인터페이스의 디폴트 메소드

### 자바 함수

자바 8에서는 이급 값이었던 메소드를 일급값으로 바꾸는 기능을 추가했다.

Class::method 처럼 메소드를 일급값으로 만들어서 코드를 마음대로 전달할 수 있다.

또한 적절한 클래스나 메소드가 없을 때는 람다 문법을 이용해서 코드를 전달하는 것도 가능해졌다. 한번만 사용할 메소드는 람다로 전달하는 것이 낫다. 물론 람다가 몇줄 이상으로 길어지면 그냥 따로 만드는게 바람직함.

### 스트림

컬렉션만 사용했을 때는 여러 문제점이 있었다.
- 코드에 제어 흐름 문장이 많아서 코드를 한번에 이해하기 힘듬
- 많은 요소를 가진 목록을 반복할 때 단일 CPU로 처리하기 때문에 시간이 오래걸림

스트림을 이용하면 위 문제들을 해결할 수 있다.
- 내부 반복을 이용하여 루프문이 드러나지 않는다
- 다른 CPU코어에 작업을 할당해서 처리시간을 줄일 수 있다.

컬렉션으로 데이터를 처리할 때, 반복되는 패턴이 존재한다. 데이터를 필터링하거나, 추출하거나, 그룹화하는 등의 패턴말이다.

이런 동작들은 쉽게 병렬화가 가능하다. 필터링할 때 데이터를 쪼개서(forking) 여러 CPU한테 맡기고 나중에 합치면 똑같으니까.

### 디폴트 메소드와 자바모듈

자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공한다.

모듈이란 패키지의 모음인데, 이를 통해 jar같은 컴포넌트에 구조를 적용할 수 있고, 문서화와 모듈 확인 작업이 용이해졌다.

자바8에서는 디폴트 메소드를 지원한다.

디폴트 메소드가 뭐냐면, 인터페이스를 구현할 때 굳이 안구현해도 되는 메소드이다.

디폴트메소드가 등장한 이유는 기존의 코드를 변경하지 않으면서 인터페이스 설계를 확장하기 위해서이다.

예를 들어 List에 sort()를 추가하고 싶은데, 모든 구현체를 다 수정하는 것은 너무 고통스럽지 않은가? 그럴 때 디폴트 메소드를 이용하면 구현체들을 굳이 수정하지 않아도 된다.

